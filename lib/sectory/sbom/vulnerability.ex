defmodule Sectory.Sbom.Vulnerability do
  @moduledoc """
  Extract data from an SBOM Vulnerability structure.
  """

  require Lens.Macros

  @severity_rank %{
    "none" => 0,
    "unknown" => 1,
    "info" => 1,
    "low" => 3,
    "medium" => 4,
    "high" => 5,
    "critical" => 6
  }

  def format_severity(v) do
    adjusted_severity =
      Lens.to_list(adjusted_severity_lens(), v)
      |> Enum.at(0, "unknown")

    case adjusted_severity do
      "unknown" -> max_severity_from_ratings(v)
      _ -> adjusted_severity
    end
  end

  defp max_severity_from_ratings(v) do
    rating_severities =
      rating_severity_lens()
      |> Lens.to_list(v)

    case rating_severities do
      [] -> "unknown"
      _ -> Enum.max_by(
        rating_severities,
        fn(v) ->
          @severity_rank[v]
        end
      )
    end
  end

  def potential?(v) do
    case {has_non_triage_state(v), potential_value(v)} do
      {true, _} -> false
      {false, "potential"} -> true
      _ -> false
    end
  end

  def component_refs(v) do
    vuln_component_ref_lens()
    |> Lens.to_list(v)
  end

  def extract_mitigation(v, components) do
    analysis = analysis_lens()
               |> Lens.one!(v)
    case analysis do
      nil -> nil
      _ ->
        construct_mitigation_statement(v, analysis, components)
    end
  end

  def tools(v) do
    Lens.key?("tools")
    |> Lens.key?("components")
    |> Lens.all()
    |> Lens.key?("name")
    |> Lens.to_list(v)
  end

  def id(v) do
    Lens.key?("id")
    |> Lens.either(Lens.const(nil))
    |> Lens.one!(v)
  end

  def detail(v) do
    Lens.key?("detail")
    |> Lens.either(
      Lens.const(nil)
    )
    |> Lens.one!(v)
  end

  def description(v) do
    case Map.has_key?(v, "description") do
      false ->
        case Map.has_key?(v, "detail") do
          false -> "NO DESCRIPTION PROVIDED"
          _ ->
            Map.fetch!(v, "detail")
            |> truncate(length: 80)
        end
      _ -> Map.fetch!(v, "description")
    end
  end

  defp construct_mitigation_statement(v, analysis, components) do
    original_severity = max_severity_from_ratings(v)
    severity = format_severity(v)
    vuln_properties = %{
      id: id(v),
      description: description(v),
      severity: severity,
      original_severity: original_severity,
      components: components,
      tools: tools(v)
    }
    Map.merge(
      mitigation_properties_for(analysis),
      vuln_properties
    )
  end

  defp mitigation_properties_for(analysis) do
    %{
      state: analysis_state(analysis),
      justification: analysis_justification(analysis),
      detail: analysis_detail(analysis)
    }
  end

  defp analysis_justification(analysis) do
    Lens.key?("justification")
    |> Lens.either(
      Lens.const(nil)
    )
    |> Lens.one!(analysis)
  end

  defp analysis_detail(analysis) do
    Lens.key?("detail")
    |> Lens.either(
      Lens.const(nil)
    )
    |> Lens.one!(analysis)
  end

  defp analysis_state(analysis) do
    Lens.key?("state")
    |> Lens.either(
      Lens.const(nil)
    )
    |> Lens.one!(analysis)
  end

  defp has_non_triage_state(v) do
    case Map.has_key?(v, "analysis") do
      false -> false
      _ -> analysis_state_value(v["analysis"])
    end
  end

  defp analysis_state_value(nil), do: nil

  defp analysis_state_value(analysis) do
    case analysis["state"] do
      "in_triage" -> false
      _ -> true
    end
  end

  defp potential_value(v) do
    case Map.has_key?(v, "properties") do
      false -> nil
      _ -> potential_property_value(v["properties"])
    end
  end

  defp potential_property_value(nil), do: nil
  defp potential_property_value([]), do: nil

  defp potential_property_value(props) do
    Enum.find(props, %{"value" => nil}, fn prop ->
      prop["name"] == "vuln-assign:certainty"
    end)["value"]
  end

  Lens.Macros.deflensp adjusted_severity_lens() do
    Lens.key?("properties")
    |> Lens.all()
    |> Lens.filter(fn v when is_map(v) ->
      (v["name"] == "vuln-assign:analysis_severity")
    end)
    |> Lens.key?("value")
  end

  Lens.Macros.deflensp rating_severity_lens() do
    Lens.key?("ratings")
    |> Lens.all()
    |> Lens.filter(fn v when is_map(v) ->
      Map.has_key?(v, "severity")
    end)
    |> Lens.key?("severity")
  end

  Lens.Macros.deflensp vuln_component_ref_lens() do
    Lens.key?("affects")
    |> Lens.all()
    |> Lens.key?("ref")
  end

  Lens.Macros.deflensp analysis_lens() do
    Lens.key?("analysis")
    |> Lens.either(Lens.const(nil))
  end

  def truncate(text, options \\ []) do
    len = options[:length] || 30
    omi = options[:omission] || "..."

    cond do
      !String.valid?(text) ->
        text

      String.length(text) < len ->
        text

      true ->
        len_with_omi = len - String.length(omi)

        stop =
          if options[:separator] do
            rindex(text, options[:separator], len_with_omi) || len_with_omi
          else
            len_with_omi
          end

        "#{String.slice(text, 0, stop)}#{omi}"
    end
  end

  defp rindex(text, str, offset) do
    text =
      if offset do
        String.slice(text, 0, offset)
      else
        text
      end

    revesed = text |> String.reverse()
    matchword = String.reverse(str)

    case :binary.match(revesed, matchword) do
      {at, strlen} ->
        String.length(text) - at - strlen

      :nomatch ->
        nil
    end
  end
end
